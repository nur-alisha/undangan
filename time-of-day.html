<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Day Cycle with Stars</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Arial', sans-serif;
      transition: background 0.5s ease;
      color: white;
      overflow: hidden;
    }
    
    #starCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <canvas id="starCanvas"></canvas>

  <script>
    // Canvas setup
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Star class
    class Star {
      constructor() {
        this.reset();
        this.y = Math.random() * canvas.height;
        this.twinkleOffset = Math.random() * Math.PI * 2;
      }
      
      reset() {
        this.x = Math.random() * canvas.width;
        this.y = -10;
        this.size = Math.random() * 1.5 + 0.5;
        this.baseOpacity = Math.random() * 0.5 + 0.5;
        this.twinkleSpeed = Math.random() * 0.02 + 0.01;
        this.speed = this.size * 0.05;
      }
      
      update() {
        this.x -= this.speed * 0.3;
        this.y += this.speed * 0.5;
        
        if (this.x < -10) this.x = canvas.width + 10;
        if (this.y > canvas.height + 10) this.y = -10;
      }
      
      draw(time, opacity) {
        const twinkle = Math.sin(time * this.twinkleSpeed + this.twinkleOffset) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(255, 255, 255, ${this.baseOpacity * twinkle * opacity})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Meteorite class
    class Meteorite {
      constructor() {
        this.x = Math.random() * canvas.width + canvas.width * 0.3;
        this.y = Math.random() * canvas.height * 0.3;
        this.vx = -(Math.random() * 3 + 5);
        this.vy = Math.random() * 2 + 3;
        this.length = Math.random() * 60 + 40;
        this.opacity = 1;
        this.life = 0;
        this.maxLife = Math.random() * 60 + 40;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life++;
        this.opacity = 1 - (this.life / this.maxLife);
      }
      
      draw(opacity) {
        const gradient = ctx.createLinearGradient(
          this.x, this.y,
          this.x - this.vx * 10, this.y - this.vy * 10
        );
        gradient.addColorStop(0, `rgba(255, 255, 255, ${this.opacity * opacity})`);
        gradient.addColorStop(0.3, `rgba(200, 220, 255, ${this.opacity * 0.6 * opacity})`);
        gradient.addColorStop(1, `rgba(150, 180, 255, 0)`);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * 10, this.y - this.vy * 10);
        ctx.stroke();
      }
      
      isDead() {
        return this.life >= this.maxLife || this.x < -100 || this.y > canvas.height + 100;
      }
    }
    
    // Create stars
    const stars = [];
    for (let i = 0; i < 300; i++) {
      stars.push(new Star());
    }
    
    // Meteorites
    const meteorites = [];
    let lastMeteorTime = 0;
    
    // Color stops for day cycle
    const colorStops = [
      { hour: 0, name: 'Night', colors: [[15, 32, 39], [32, 58, 67], [44, 83, 100]] },
      { hour: 5, name: 'Pre-Dawn', colors: [[15, 32, 39], [32, 58, 67], [44, 83, 100]] },
      { hour: 6, name: 'Dawn', colors: [[255, 107, 107], [254, 202, 87], [72, 219, 251]] },
      { hour: 7, name: 'Early Morning', colors: [[189, 212, 214], [100, 150, 200], [2, 81, 250]] },
      { hour: 10, name: 'Morning', colors: [[189, 212, 214], [2, 81, 250], [0, 50, 200]] },
      { hour: 14, name: 'Afternoon', colors: [[135, 206, 235], [74, 144, 226], [50, 120, 200]] },
      { hour: 17, name: 'Late Afternoon', colors: [[135, 206, 235], [255, 150, 100], [74, 144, 226]] },
      { hour: 18, name: 'Golden Hour', colors: [[255, 107, 107], [255, 140, 66], [238, 90, 111]] },
      { hour: 19, name: 'Sunset', colors: [[255, 107, 107], [255, 100, 80], [100, 50, 80]] },
      { hour: 20, name: 'Dusk', colors: [[67, 67, 67], [30, 30, 50], [0, 0, 0]] },
      { hour: 21, name: 'Night', colors: [[15, 32, 39], [32, 58, 67], [44, 83, 100]] },
      { hour: 24, name: 'Night', colors: [[15, 32, 39], [32, 58, 67], [44, 83, 100]] }
    ];
    
    // Initialize with device's real time
    const now = new Date();
    let currentHour = now.getHours();
    let currentMinute = now.getMinutes();
    let baseSpeed = 0.5; // Normal speed (0.5 minutes per frame)
    let speedMultiplier = 1;
    let animationTime = 0;
    
    // Keyboard controls
    let rightKeyPressed = false;
    
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') {
        rightKeyPressed = true;
        speedMultiplier = 20; // 20x faster when holding right arrow
      }
    });
    
    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowRight') {
        rightKeyPressed = false;
        speedMultiplier = 1;
      }
    });
    
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    
    function lerpColor(color1, color2, t) {
      return [
        lerp(color1[0], color2[0], t),
        lerp(color1[1], color2[1], t),
        lerp(color1[2], color2[2], t)
      ];
    }
    
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }
    
    function getInterpolatedGradient(decimalHour) {
      let startStop, endStop;
      
      for (let i = 0; i < colorStops.length - 1; i++) {
        if (decimalHour >= colorStops[i].hour && decimalHour < colorStops[i + 1].hour) {
          startStop = colorStops[i];
          endStop = colorStops[i + 1];
          break;
        }
      }
      
      if (!startStop || !endStop) {
        startStop = colorStops[colorStops.length - 1];
        endStop = colorStops[0];
      }
      
      const totalDuration = endStop.hour - startStop.hour;
      const elapsed = decimalHour - startStop.hour;
      const t = totalDuration > 0 ? elapsed / totalDuration : 0;
      const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      
      const color1 = lerpColor(startStop.colors[0], endStop.colors[0], eased);
      const color2 = lerpColor(startStop.colors[1], endStop.colors[1], eased);
      const color3 = lerpColor(startStop.colors[2], endStop.colors[2], eased);
      
      const hex1 = rgbToHex(color1[0], color1[1], color1[2]);
      const hex2 = rgbToHex(color2[0], color2[1], color2[2]);
      const hex3 = rgbToHex(color3[0], color3[1], color3[2]);
      
      return {
        gradient: `linear-gradient(135deg, ${hex1} 0%, ${hex2} 50%, ${hex3} 100%)`,
        name: t < 0.5 ? startStop.name : endStop.name
      };
    }
    
    function getStarOpacity(decimalHour) {
      if (decimalHour >= 21 || decimalHour < 5) return 1;
      if (decimalHour >= 5 && decimalHour < 7) return 1 - (decimalHour - 5) / 2;
      if (decimalHour >= 19 && decimalHour < 21) return (decimalHour - 19) / 2;
      return 0;
    }
    
    function updateBackground() {
      const decimalHour = currentHour + (currentMinute / 60);
      const result = getInterpolatedGradient(decimalHour);
      document.body.style.background = result.gradient;
    }
    
    function advanceTime() {
      currentMinute += baseSpeed * speedMultiplier;
      
      if (currentMinute >= 60) {
        currentMinute = currentMinute % 60;
        currentHour++;
        
        if (currentHour >= 24) {
          currentHour = 0;
        }
      }
      
      updateBackground();
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      advanceTime();
      
      const decimalHour = currentHour + (currentMinute / 60);
      const starOpacity = getStarOpacity(decimalHour);
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (starOpacity > 0) {
        animationTime += 0.1;
        stars.forEach(star => {
          star.update();
          star.draw(animationTime, starOpacity);
        });
        
        if (starOpacity > 0.5 && Math.random() < 0.01 && Date.now() - lastMeteorTime > 3000) {
          meteorites.push(new Meteorite());
          lastMeteorTime = Date.now();
        }
        
        for (let i = meteorites.length - 1; i >= 0; i--) {
          meteorites[i].update();
          meteorites[i].draw(starOpacity);
          
          if (meteorites[i].isDead()) {
            meteorites.splice(i, 1);
          }
        }
      }
    }
    
    // Initialize
    updateBackground();
    animate();
  </script>
</body>
</html>